//
// Паттерн "Фасад" предоставляет унифицированный интерфейс вместо набора интерфейсов
// некоторой подсистемы. Фасад определяет интерфейс более высокого уровня, который
// упрощает использование подсистемы.
//
// Паттер "Фасад" используют, когда:
// - Имеется сложная система, и необходимо упростить с ней работу.
// Фасад позволит определить одну точку взаимодействия между клиентом и системой.
// - Надо уменьшить количество зависимостей между клиентом и сложной системой.
// Фасадные объекты позволяют отделить, изолировать компоненты системы от клиента и
// развивать и работать с ними независимо.
// - Нужно определить подсистемы компонентов в сложной системе. Создание фасадов
// для компонентов каждой отдельной подсистемы позволит упростить взаимодействие
// между ними и повысить их независимость друг от друга.
//
// Пример использования паттерна в реальной задаче.
// Писать код в интегрированных средах разработки намного удобнее по сравнению с тем, как писался
// код ранее до появления интегрированных сред разработки. Мы просто пишем код, нажимаем на кнопку
// и все - приложение готово. В данном случае интегрированная среда разработки представляет собой
// фасад, который скрывает всю сложность процесса компиляции и запуска приложения.
//

package pattern

import "fmt"

// Классы SubsystemA, SubsystemB, SubsystemC и т.д. являются компонентами
// сложной подсистемы, с которыми должен взаимодействовать клиент

type SubsystemA struct{}

func (s *SubsystemA) A1() string {
	return "Subsystem A, Method A1\n"
}

func (s *SubsystemA) A2() string {
	return "Subsystem A, Method A2\n"
}

type SubsystemB struct{}

func (s *SubsystemB) B1() string {
	return "Subsystem B, Method B1\n"
}

type SubsystemC struct{}

func (s *SubsystemC) C1() string {
	return "Subsystem C, Method C1\n"
}

// Facade - непосредственно фасад, который предоставляет
// интерфейс клиенту для работы с компонентами
type Facade struct {
	a *SubsystemA
	b *SubsystemB
	c *SubsystemC
}

func (f *Facade) Operation1() {
	fmt.Println("Operation 1\n" +
		f.a.A1() +
		f.a.A2() +
		f.b.B1())
}

func (f *Facade) Operation2() {
	fmt.Println("Operation 2\n" +
		f.b.B1() +
		f.c.C1())
}

func NewFacade() *Facade {
	return &Facade{a: &SubsystemA{}, b: &SubsystemB{}, c: &SubsystemC{}}
}

func DemonstrateFacade() {
	f := NewFacade()
	f.Operation1()
	f.Operation2()
}
