//
// Паттерн «Фасад» предоставляет унифицированный интерфейс вместо набора интерфейсов
// некоторой подсистемы. Фасад определяет интерфейс более высокого уровня, который
// упрощает использование подсистемы.
//
// Паттер "Фасад" используют когда:
// - Когда имеется сложная система, и необходимо упростить с ней работу.
// Фасад позволит определить одну точку взаимодействия между клиентом и системой.
// - Когда надо уменьшить количество зависимостей между клиентом и сложной системой.
// Фасадные объекты позволяют отделить, изолировать компоненты системы от клиента и
// развивать и работать с ними независимо.
// - Когда нужно определить подсистемы компонентов в сложной системе. Создание фасадов
// для компонентов каждой отдельной подсистемы позволит упростить взаимодействие
// между ними и повысить их независимость друг от друга.
//
// Пример использования паттерна в реальной задаче.
// Писать код в интегрированных средах разработки намного удобнее по сравнению с тем, как писался
// код ранее до появления интегрированных сред разработки. Мы просто пишем код, нажимаем на кнопку
// и все - приложение готово. В данном случае интегрированная среда разработки представляет собой
// фасад, который скрывает всю сложность процесса компиляции и запуска приложения.
//

package pattern

import "fmt"

type subsystemA struct{}

func (s *subsystemA) A1() string {
	return "Subsystem A, Method A1\n"
}

func (s *subsystemA) A2() string {
	return "Subsystem A, Method A2\n"
}

type subsystemB struct{}

func (s *subsystemB) B1() string {
	return "Subsystem B, Method B1\n"
}

type subsystemC struct{}

func (s *subsystemC) C1() string {
	return "Subsystem C, Method C1\n"
}

type facade struct {
	a *subsystemA
	b *subsystemB
	c *subsystemC
}

func (f *facade) Operation1() {
	fmt.Println("Operation 1\n" +
		f.a.A1() +
		f.a.A2() +
		f.b.B1())
}

func (f *facade) Operation2() {
	fmt.Println("Operation 2\n" +
		f.b.B1() +
		f.c.C1())
}

func NewFacade() *facade {
	return &facade{a: &subsystemA{}, b: &subsystemB{}, c: &subsystemC{}}
}
